{"meta":{"title":"Mr.song","subtitle":"step by step","description":"A journey of a thousand miles begins with single step","author":"songgl","url":"http://yoursite.com"},"pages":[{"title":"","date":"2017-03-18T14:27:55.000Z","updated":"2017-03-18T15:01:02.000Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"Hmmmm……还没想好写点啥~~~"},{"title":"categories","date":"2017-03-18T05:16:38.000Z","updated":"2017-03-18T15:01:02.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-03-18T05:15:36.000Z","updated":"2017-03-18T15:01:02.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"golang中slice越界问题","slug":"go-slice-append","date":"2017-06-20T16:02:26.000Z","updated":"2017-06-20T16:27:59.000Z","comments":true,"path":"go-slice-append/","link":"","permalink":"http://yoursite.com/go-slice-append/","excerpt":"go中slice由于其类似于一个长度可动态变化的数组而非常方便使用。slice有两个基本属性：cap,len，分别代表容量和已有数据长度。一般声明slice的两种方式如下：1234//定义了一个初始长度为0,容量为2的int 类型的 `slice`slice:=make([]int,0,2)var slice=[]int&#123;0,1&#125; 往slice中添加元素使用append方法：1slice=append(slice,1)","text":"go中slice由于其类似于一个长度可动态变化的数组而非常方便使用。slice有两个基本属性：cap,len，分别代表容量和已有数据长度。一般声明slice的两种方式如下：1234//定义了一个初始长度为0,容量为2的int 类型的 `slice`slice:=make([]int,0,2)var slice=[]int&#123;0,1&#125; 往slice中添加元素使用append方法：1slice=append(slice,1) 当然有时也可以使用索引值来直接赋值：1slice[0]=1 不过这种方式需要注意的是，索引的值不能大于slice的容量(cap)，否则会报出panic: runtime error: index out of range错误。所以一般情况下应该优先使用append的方法给slice添加元素。 同样，对slice或者array进行切片(slice)操作的时候，索引也不能超过当前slice的容量或者array的长度123var slice = []int&#123;0, 1, 2, 3, 4, 5, 6&#125;fmt.Println(slice[:5]) //[0,1,2,3,4]fmt.Println(slice[1:10]) //slice bounds out of range slice的容量扩容规则： 当容量不够时，容量扩充为之前容量的2倍 在调用append方法给slice添加元素的时候，可以一次添加多个或者全部：123456var slice = []int&#123;0,1&#125;var slice2 = []int&#123;2,3&#125;fmt.Println(append(slice,slice2...)) //[0,1,2,3]fmt.Println(append(slice,4,5)) //[0,1,4,5]","categories":[{"name":"go","slug":"go","permalink":"http://yoursite.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"http://yoursite.com/tags/go/"},{"name":"slice","slug":"slice","permalink":"http://yoursite.com/tags/slice/"}]},{"title":"Mac上使用gdb单步调试golang程序","slug":"debug-golang-with-gdb-on-mac","date":"2017-06-07T14:29:40.000Z","updated":"2017-06-21T11:53:26.000Z","comments":true,"path":"debug-golang-with-gdb-on-mac/","link":"","permalink":"http://yoursite.com/debug-golang-with-gdb-on-mac/","excerpt":"单步调试最近在写golang程序的时候，想要想单步调试一下程序，减少手动print log调试代码的痛苦。 找了一些golang单步调试的方案，主要有几下几种方案: 使用 SublimeGDB 插件在Sublime 中调试 使用 Goland IDE 调试,不过可惜Goland还未发布正式版本 使用 gdb 工具调试 每个都尝试了一遍: SublimeGDB 界面不错，但是调试速度太慢，设置一个断点都需要很长时间，故 pass 此方案。 Goland IDE 只是预览版，有使用时间限制,还是等等吧，等 Jetbrains 出正式版后再去试试.(Jetbrains出品必属精品) gdb调试，使用下来发现，目前而言，gdb的方式还是用的比较顺手的。 不过在mac电脑上使用gdb还是遇到了一些问题,不过还好都顺利解决了。","text":"单步调试最近在写golang程序的时候，想要想单步调试一下程序，减少手动print log调试代码的痛苦。 找了一些golang单步调试的方案，主要有几下几种方案: 使用 SublimeGDB 插件在Sublime 中调试 使用 Goland IDE 调试,不过可惜Goland还未发布正式版本 使用 gdb 工具调试 每个都尝试了一遍: SublimeGDB 界面不错，但是调试速度太慢，设置一个断点都需要很长时间，故 pass 此方案。 Goland IDE 只是预览版，有使用时间限制,还是等等吧，等 Jetbrains 出正式版后再去试试.(Jetbrains出品必属精品) gdb调试，使用下来发现，目前而言，gdb的方式还是用的比较顺手的。 不过在mac电脑上使用gdb还是遇到了一些问题,不过还好都顺利解决了。 遇到的主要问题有权限问题和 mac系统版本问题 权限问题mac 系统为了安全起见，不允许普通用户直接运行gdb,运行时会出现以下问题：12Unable to find Mach task port for process-id 4263: (os/kern) failure (0x5). (please check gdb is codesigned - see taskgated(8)) 这个问题，网络上已有解决方案，比如对gdb进行签名啥的，嫌麻烦，没有尝试。详细步骤见这里这里直接使用 sudo gdb ..来运行。可以自行设置命令alias。 1alias gdb='sudo gdb' 不过这样就得每次输入系统密码了。不过可以使用 expect 来让命令行自动输入密码(这是后话)。 版本问题开始调试的时候遇到了一下问题：1During startup program terminated with signal ?, Unknown signal. 查询了一下，Mac Sierra 这个版本的系统不支持 gdb 调试。解决方案五花八门。主要进行了一下操作：123brew upgrade gdb touch ~/.gdbinitcat 'set startup-with-shell off' &gt; ~/.gdbinit 这些操作主要是: 将 gdb 从 7.1.2升级到最新的 8.0 给 gdb 写入配置文件 幸运的是，经过这两步的处理，gdb 已经能够在本人机器上正常运行了。 下面记录下一些 常用的gdb操作: command alias description l main.main list main.main 查看 golang main函数入口源码 b 12 breakpoints 12 在12行设置一个断点 d delete 删除所有断点 i b info breakpoints 查看已经设置的断点 r run 开始运行程序 n next 执行下一行，相当于step over s - 进入函数内部，相当于step into i locals info locals 查看局部变量 i args info args 查看参数 p paramName print paramName 打印变量 c - 继续执行，直到下一个断点 whatis paramName - 查看变量类型 up - 返回上一次函数 down - 进入下一层函数 h help help","categories":[{"name":"go","slug":"go","permalink":"http://yoursite.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"http://yoursite.com/tags/go/"},{"name":"gdb","slug":"gdb","permalink":"http://yoursite.com/tags/gdb/"},{"name":"debug","slug":"debug","permalink":"http://yoursite.com/tags/debug/"}]},{"title":"压力测试工具ab、webbench、http_load、siege简单使用","slug":"pressure-test-tools","date":"2017-06-05T02:05:14.000Z","updated":"2017-06-05T14:39:48.000Z","comments":true,"path":"pressure-test-tools/","link":"","permalink":"http://yoursite.com/pressure-test-tools/","excerpt":"本文简单介绍ab、http_load、webbench、siege四种压力测试工具的使用。 abab 是 apache 服务器自带的一个压力测试工具。安装apache web服务器时就自动安装了。当然，ab也是可以单独安装的，如果你不想安装apache而只是想安装ab，那么可以使用以下方式安装:1[root@yourdream ~]# yum install httpd-tools 安装完成之后即可使用ab进行测试了。1234567[root@yourdream ~]# ab -hUsage: ab [options] [http[s]://]hostname[:port]/pathOptions are: -n requests Number of requests to perform -c concurrency Number of multiple requests to make .... -h Display usage information (this message)","text":"本文简单介绍ab、http_load、webbench、siege四种压力测试工具的使用。 abab 是 apache 服务器自带的一个压力测试工具。安装apache web服务器时就自动安装了。当然，ab也是可以单独安装的，如果你不想安装apache而只是想安装ab，那么可以使用以下方式安装:1[root@yourdream ~]# yum install httpd-tools 安装完成之后即可使用ab进行测试了。1234567[root@yourdream ~]# ab -hUsage: ab [options] [http[s]://]hostname[:port]/pathOptions are: -n requests Number of requests to perform -c concurrency Number of multiple requests to make .... -h Display usage information (this message) 压力测试的时候一般使用到 -n和-c参数来分别指定运行次数和并发数:123456789101112131415161718192021222324252627282930313233343536[root@yourdream ~]# ab -n 1000 -c 100 https://baidu.com/This is ApacheBench, Version 2.3 &lt;$Revision: 655654 $&gt;Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/Licensed to The Apache Software Foundation, http://www.apache.org/Benchmarking baidu.com (be patient)Completed 100 requests...Completed 1000 requestsFinished 1000 requests....Concurrency Level: 100Time taken for tests: 3.742 secondsComplete requests: 1000Failed requests: 0Write errors: 0...Requests per second: 267.23 [#/sec] (mean)Time per request: 374.213 [ms] (mean)Time per request: 3.742 [ms] (mean, across all concurrent requests)Transfer rate: 92.50 [Kbytes/sec] receivedConnection Times (ms) min mean[+/-sd] median maxConnect: 93 260 50.7 269 498Processing: 26 88 45.6 77 362Waiting: 25 62 31.8 50 356Total: 125 348 47.5 342 635Percentage of the requests served within a certain time (ms) 50% 342 .... 99% 534 100% 635 (longest request) 测试结果中，重点关注Requests per second和Time per request 指标,分别是每秒请求数和单个请求耗时。注意这些指标只能作为性能参考，因为会受到各种因素的影响，比如网络环境的影响… http_loadhttp_load非常轻量，程序解压后100kb左右的大小。不过不支持直接测试url，需要先将要测试的url写入文件，把文件作为参数传递给http_load。1234567[root@yourdream ~]# http_loadusage: http_load [-checksum] [-throttle] [-proxy host:port] [-verbose] [-timeout secs] [-sip sip_file] -parallel N | -rate N [-jitter] -fetches N | -seconds N url_fileOne start specifier, either -parallel or -rate, is required.One end specifier, either -fetches or -seconds, is required. 经常需要使用到的参数是-parallel和-fetches，分别表示并发数和总共请求数。12345678910[root@yourdream ~]# http_load -parallel 100 -fetches 1000 a.txt....1000 fetches, 100 max parallel, 55088 bytes, in 1.8685 seconds55.088 mean bytes/connection535.189 fetches/sec, 29482.5 bytes/secmsecs/connect: 31.5979 mean, 48.524 max, 26.395 minmsecs/first-response: 36.9429 mean, 1312.77 max, 5.107 min999 bad byte countsHTTP response codes: code 200 -- 514 测试结果中，重点关注fetches/sec和msecs/connect,分别表示每秒处理请求数和每个连接平均响应时间。 webbenchwebbench 也非常轻量级，和http_load大小差不多。12345678910111213141516[root@yourdream ~]# webbenchwebbench [option]... URL -f|--force Don&apos;t wait for reply from server. -r|--reload Send reload request - Pragma: no-cache. -t|--time &lt;sec&gt; Run benchmark for &lt;sec&gt; seconds. Default 30. -p|--proxy &lt;server:port&gt; Use proxy server for request. -c|--clients &lt;n&gt; Run &lt;n&gt; HTTP clients at once. Default one. -9|--http09 Use HTTP/0.9 style requests. -1|--http10 Use HTTP/1.0 protocol. -2|--http11 Use HTTP/1.1 protocol. --get Use GET request method. --head Use HEAD request method. --options Use OPTIONS request method. --trace Use TRACE request method. -?|-h|--help This information. -V|--version Display program version. webbench不支持指定总访问数，支持并发数(-c)和测试时长(-t)，不直接支持https测试。123456789[root@yourdream ~]# webbench -c 100 -t 10 http://baidu.com/Webbench - Simple Web Benchmark 1.5Copyright (c) Radim Kolar 1997-2004, GPL Open Source Software.Benchmarking: GET http://baidu.com/100 clients, running 10 sec.Speed=14628 pages/min, 2448 bytes/sec.Requests: 86 susceed, 2352 failed. 每秒钟响应请求数：146285 pages/min，每秒钟传输数据量:2448 bytes/sec siege安装可以直接使用yum、apt安装，也自己去下载手动安装。123456789101112131415[root@yourdream ~]# siegeSIEGE 3.0.8Usage: siege [options] siege [options] URL siege -g URLOptions: ... -h, --help HELP, prints this section. ... -c, --concurrent=NUM CONCURRENT users, default is 10 -i, --internet INTERNET user simulation, hits URLs randomly. ... -t, --time=NUMm TIMED testing where &quot;m&quot; is modifier S, M, or H ex: --time=1H, one hour test. ... 经常使用的参数是-c和-t，分别是并发数和测试时长。12345678910111213141516171819202122[root@yourdream ~]# siege -c 100 -t 10S https://baidu.com** SIEGE 3.0.8** Preparing 100 concurrent users for battle.The server is now under siege...HTTP/1.1 200 0.03 secs: 28207 bytes ==&gt; GET /HTTP/1.1 302 0.15 secs: 161 bytes ==&gt; GET /....Lifting the server siege.. done.Transactions: 1512 hitsAvailability: 100.00 %Elapsed time: 9.63 secsData transferred: 20.38 MBResponse time: 0.12 secsTransaction rate: 157.01 trans/secThroughput: 2.12 MB/secConcurrency: 18.14Successful transactions: 1555Failed transactions: 0Longest transaction: 1.34Shortest transaction: 0.02... 测试结果中，重点关注Transaction rate和Concurrency，分别表示每秒处理数和实际并发数。siege可以将测试结果写入日志文件中，方便进行后续图形化工具或者分析工具使用。12 Date &amp; Time, Trans, Elap Time, Data Trans, Resp Time, Trans Rate, Throughput, Concurrent, OKAY, Failed2017-06-05 11:38:02, 1512, 9.63, 20, 0.12, 157.01, 2.08, 18.14, 1555, 0","categories":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"}],"tags":[{"name":"ab","slug":"ab","permalink":"http://yoursite.com/tags/ab/"},{"name":"webbench","slug":"webbench","permalink":"http://yoursite.com/tags/webbench/"},{"name":"http_load","slug":"http-load","permalink":"http://yoursite.com/tags/http-load/"},{"name":"siege","slug":"siege","permalink":"http://yoursite.com/tags/siege/"}]},{"title":"js 回调函数访问上下文 this 对象","slug":"js-pass-this-into-callback-function","date":"2017-05-27T10:10:14.000Z","updated":"2017-06-21T11:53:26.000Z","comments":true,"path":"js-pass-this-into-callback-function/","link":"","permalink":"http://yoursite.com/js-pass-this-into-callback-function/","excerpt":"在开发项目之中，使用到js ajax 同服务端进行数据交互。一般图方便直接使用jquery或者axios等已有的库。一般代码如下:12345678//axiosaxios.get('/url').then(function(res)&#123; console.log(res)&#125;)//juqery$.get('/url',function(res)&#123; console.log(res)&#125;,'json') 那么经常这么使用的肯定会遇到一个场景，就是:在回调函数中如何访问上下文中的this对象?","text":"在开发项目之中，使用到js ajax 同服务端进行数据交互。一般图方便直接使用jquery或者axios等已有的库。一般代码如下:12345678//axiosaxios.get('/url').then(function(res)&#123; console.log(res)&#125;)//juqery$.get('/url',function(res)&#123; console.log(res)&#125;,'json') 那么经常这么使用的肯定会遇到一个场景，就是:在回调函数中如何访问上下文中的this对象?123456function request()&#123; //this axios.get('/url').then(function(res)&#123; //in callbacl ,how to access this &#125;)&#125; 之前的做法是这样的:将this赋值给一个局部变量,然后在回调函数中访问这个变量12345678function request()&#123; //this var that = this; axios.get('/url').then(function(res)&#123; //in callbacl ,how to access this console.log(that) &#125;)&#125; 后来知道了更为优雅的两种方式: 使用 bind函数:123456789101112//axiosfunction request()&#123; axios.get('/url').then(function(res)&#123; console.log(this); &#125;.bind(this));&#125;//jqueryfunction request()&#123; $.get('/url',function(res)&#123; console.log(this); &#125;.bind(this),'json');&#125; 使用ES6的箭头函数:123456789101112//axiosfunction request()&#123; axios.get('/url').then((res)=&gt;&#123; console.log(this); ));&#125;//juqeryfunction request()&#123; $.get('/url',(res)=&gt;&#123; console.log(this); &#125;,'json');&#125; 参考: 深入浅出ES6（七）：箭头函数 Arrow Functions","categories":[{"name":"notes","slug":"notes","permalink":"http://yoursite.com/categories/notes/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"mysql unsigned/int字段越界","slug":"mysql-bigint-out-of-range","date":"2017-05-22T02:41:39.000Z","updated":"2017-06-05T14:39:48.000Z","comments":true,"path":"mysql-bigint-out-of-range/","link":"","permalink":"http://yoursite.com/mysql-bigint-out-of-range/","excerpt":"线上的MySQL错误日志中遇到了以下问题1Data truncation: BIGINT UNSIGNED value is out of range in `(database.tablename.fieldname)` MySQL版本为:1234567mysql&gt; select version();+------------+| version() |+------------+| 5.6.21-log |+------------+1 row in set (0.00 sec) 引起这个错误的原因是sql语句中对unsigned字段进行了递减操作的结果为负数导致的,1update database.tablename set fieldname=fieldname-num 而MySQL的模式是默认的mode:1234567mysql&gt; show variables like 'sql_mode';+---------------+------------------------+| Variable_name | Value |+---------------+------------------------+| sql_mode | NO_ENGINE_SUBSTITUTION |+---------------+------------------------+1 row in set (0.00 sec) 解决方案有3种:","text":"线上的MySQL错误日志中遇到了以下问题1Data truncation: BIGINT UNSIGNED value is out of range in `(database.tablename.fieldname)` MySQL版本为:1234567mysql&gt; select version();+------------+| version() |+------------+| 5.6.21-log |+------------+1 row in set (0.00 sec) 引起这个错误的原因是sql语句中对unsigned字段进行了递减操作的结果为负数导致的,1update database.tablename set fieldname=fieldname-num 而MySQL的模式是默认的mode:1234567mysql&gt; show variables like 'sql_mode';+---------------+------------------------+| Variable_name | Value |+---------------+------------------------+| sql_mode | NO_ENGINE_SUBSTITUTION |+---------------+------------------------+1 row in set (0.00 sec) 解决方案有3种: 1.程序中做数据合法性检查，先查询出来，递减之后判断结果，结果正常再去插入，不过这样需要2次sql操作，需要保证操作的原子性，不然容易引起数据一致性问题. 2.在同一个session中临时修改MySQL的sql_mode:12SET sql_mode='NO_UNSIGNED_SUBTRACTION';UPDATE database.tablename SET fieldname=fieldname-num NO_UNSIGNED_SUBTRACTION 模式下，对于unsigned字段，如果插入负值，则会讲该字段的值自动设置为 0 . 3.如果unsigned字段能接受负值,则可以使用CAST函数处理:12SET sql_mode='NO_UNSIGNED_SUBTRACTION';UPDATE database.tablename SET fieldname=CAST(fieldname-num AS UNSIGNED); 需要注意的是CAST的表现会因不同的sql_mode而不同，需要合适的sql_mode和CAST配合使用. 参考: mysql out-of-range-and-overflow mysql sql mode mysql no_unsigned_subtraction mode","categories":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/categories/mysql/"}],"tags":[{"name":"database","slug":"database","permalink":"http://yoursite.com/tags/database/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"Linux强制卸载设备","slug":"umount-device-when-its-buzy","date":"2017-05-12T03:04:07.000Z","updated":"2017-05-16T13:45:38.000Z","comments":true,"path":"umount-device-when-its-buzy/","link":"","permalink":"http://yoursite.com/umount-device-when-its-buzy/","excerpt":"","text":"Linux下因为磁盘出问题而导致了Input/output error,所以准备先把有问题的磁盘卸载掉再重新挂上试试。 执行umount:1234[root@hostname ~]# umount -n /dev/sdc1umount: /home/data: device is busy. (In some cases useful info about processes that use the device is found by lsof(8) or fuser(1)) 显示设备正忙，所以执行umount -nf:123456[root@hostname ~]# umount -nf /dev/sdc1umount2: Device or resource busyumount: /home/data: device is busy. (In some cases useful info about processes that use the device is found by lsof(8) or fuser(1))umount2: Device or resource busy 还是无法卸载。 根据给出的提示，使用losf或者fuser来找出那些进程正在使用该设备:123[root@yourdream ~]# fuser -cu /dev/sdc1/dev/sdc1: 2444c(root) 2458c(root) 3041c(mysql)[root@yourdream ~]# fuser -cu /dev/sdc1 使用c指定挂载的文件系统，u显示使用者的id。可以看出三个进程正在使用，通过ps可以查到分别为redis和mysql正在使用。因此，卸载之前停掉redis和mysql之后再次执行umount就能正常卸载了。","categories":[{"name":"notes","slug":"notes","permalink":"http://yoursite.com/categories/notes/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"I-love-vim","slug":"i-love-vim","date":"2017-05-07T14:08:15.000Z","updated":"2017-06-22T14:54:38.000Z","comments":true,"path":"i-love-vim/","link":"","permalink":"http://yoursite.com/i-love-vim/","excerpt":"","text":"个人是一个vi重度使用者，所以尽可能的会希望所使用的工具中都能支持vim来方便操作。 chrome浏览器支持 vim操作: Vimium 扩展 atom 编辑器: vim-mode、vim-mode-plus sublime text: 天然支持，配置中ignored_packages 置为空[]即可 idea 编辑器：vim 插件用来编辑文件内容，还有一个和Vimium相似的插件(名称遗忘,自己未使用)，以和Vimium相同的方式操作idea的各种菜单 command line: 大部分天然支持vim编辑模式 (非 windows 系统),自行给vim安装了一些插件，打造成了一个命令行的golang的IDE 目录：scrooloose/nerdtree 目录git状态：Xuyuanp/nerdtree-git-plugin 自动完成：Shougo/neocomplete go相关格式等工具：fatih/vim-go 最后，附上一张命令行IDE效果图:","categories":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"}],"tags":[{"name":"vim","slug":"vim","permalink":"http://yoursite.com/tags/vim/"}]},{"title":"dbm--python的一个简易K-V数据库","slug":"python-dbm","date":"2017-05-07T13:46:13.000Z","updated":"2017-05-07T14:02:01.000Z","comments":true,"path":"python-dbm/","link":"","permalink":"http://yoursite.com/python-dbm/","excerpt":"","text":"在一些小型简单的python程序中,不需要(不想)引入庞大的关系型数据库或者其他大型的非关系型数据库(NoSql)时，dbm模块是一个非常不错的选择。不过在使用的时候需要注意的是，它要求key,value均为字符串类型。可以对其进行一个简单的封装，便于使用。12345678910111213141516171819202122232425#!/usr/bin/env python# -*- coding: utf-8 -*-import dbmfrom models.Config.Config import Configclass DBM(object): def __init__(self): self._db = dbm.open(Config.parse_config('dbm', 'dbfile'), 'c') def set(self, key, value): self._db[key] = str(value) return self def del(self, key): if key in self._db.keys(): del self._db[key] def get(self, key): if key in self._db.keys(): return self._db[key] else: return None def __del__(self): self._db.close() Config 是自己封装的一个简易的配置文件解析的类，负责从ini文件中读取指定的配置 dbm 的 api 非常简单，set、del、keys，其数据结构和字典非常相似，可以在小型项目中来当做简易的K/V数据库来使用。","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"database","slug":"database","permalink":"http://yoursite.com/tags/database/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"dbm","slug":"dbm","permalink":"http://yoursite.com/tags/dbm/"}]},{"title":"hexo 命令备忘录","slug":"hexo-command-notes","date":"2017-05-07T13:35:26.000Z","updated":"2017-05-07T13:42:43.000Z","comments":true,"path":"hexo-command-notes/","link":"","permalink":"http://yoursite.com/hexo-command-notes/","excerpt":"","text":"这里记录个人一些 hexo 常用命令备查: 创建新的文章: hexo new post-title 生成db和静态文件： hexo generate,缩写为 hexo g 删除cache和静态文件：hexo clean 本地开始预览server：hexo server,缩写为 hexo s,默认端口为 4000 部署到远程: hexo deply,缩写为 hexo d 有时候部署到远程后发现blog并没有更新，则可以先clean之后再 deploy:12hexo cleanhexo g -d","categories":[{"name":"notes","slug":"notes","permalink":"http://yoursite.com/categories/notes/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"http://yoursite.com/tags/blog/"}]},{"title":"中文正则匹配","slug":"regex-match-chinese","date":"2017-05-07T12:36:05.000Z","updated":"2017-05-07T13:28:40.000Z","comments":true,"path":"regex-match-chinese/","link":"","permalink":"http://yoursite.com/regex-match-chinese/","excerpt":"","text":"在某些场景下，需要使用正则对文本中的中文进行匹配。之前就在一个python的项目中需要对中文进行相应的匹配。实际需求: 要求匹配非中文内容。中文的unicode编码范围为 u4e00 到 u9fa5。123456789#!/usr/bin/env python# -*- coding: utf-8 -*-import regroup = re.search(ur'([^\\u4e00-\\u9fa5])','1中文en汉字')if group: print grou.groups() Tips: 1.正则非匹配: ^2.正则范围匹配: [a-b]3.正则捕获: ()4.python2 中 u 表示 unicode的字符串, python3 已经全部使用unicode来表示字符串5.python 中 r 表示 row string,使用原始字符串，不进行转义","categories":[{"name":"notes","slug":"notes","permalink":"http://yoursite.com/categories/notes/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"regex","slug":"regex","permalink":"http://yoursite.com/tags/regex/"}]},{"title":"shell脚本修改环境变量","slug":"shell-change-path","date":"2017-04-28T04:04:50.000Z","updated":"2017-04-28T13:11:08.000Z","comments":true,"path":"shell-change-path/","link":"","permalink":"http://yoursite.com/shell-change-path/","excerpt":"","text":"有时候编写go程序的时候需要将当前目录加到系统GOPATH中，不然就得将代码放置在已有的GOPATH之下。所以一般习惯在项目根目录执行创建一个shell脚本来动态的修改GOPTAH。脚本很简单，代码如下:123#/bin/shCURRENT=`pwd`export GOPATH=\"$&#123;GOPATH&#125;:$&#123;CURRENT&#125;\" 因为是shell脚本，所以就习惯性的执行了如下命令:12sh envecho $GOPATH 期望GOPATH中已经追加上了当前目录，然而事与愿违，并没有什么效果，GOPATH仍然是之前的内容。 原因:使用 sh 命令来执行shell脚本的时候,脚本真正是在sh创建的子shell中执行,所以当sh进程完成的时候并没有修改系统变量,所以通过执行 sh env 来修改系统变量是无效的。子shell和父shell彼此无法使用对方的变量，子shell对环境变量的修改也不会影响父shell。需要使用 source env来执行，source命令执行脚本的时候，是在source当前shell中执行的,并不会创建子shell。 参考: 用source 执行脚本和用sh 执行脚本有什么区别","categories":[{"name":"notes","slug":"notes","permalink":"http://yoursite.com/categories/notes/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/tags/Shell/"}]},{"title":"Alfred 编写 workflow","slug":"alfred-workflow","date":"2017-03-26T14:41:37.000Z","updated":"2017-04-28T13:11:03.000Z","comments":true,"path":"alfred-workflow/","link":"","permalink":"http://yoursite.com/alfred-workflow/","excerpt":"Alfred 的一个亮点功能就是workflow。通过workflow用户可以很容易的扩展alfred的功能,而开源的优秀的workflow也有很多，不过如果找不到自己满意的workflow，可以自己动手编写workflow。自己动手，丰衣足食！之所以重复造轮子的原因的是因为这个datetie-format-converter 转换的时间是按照UTC-GMT时间来算的，所以对于中国来说，属于东八区，所以就写了一个php版本的自己使用。这里只是简单记录下自己开发的一个Unix时间戳转换的workflow的过程，详细教程请自行google或者参考 这篇教程.","text":"Alfred 的一个亮点功能就是workflow。通过workflow用户可以很容易的扩展alfred的功能,而开源的优秀的workflow也有很多，不过如果找不到自己满意的workflow，可以自己动手编写workflow。自己动手，丰衣足食！之所以重复造轮子的原因的是因为这个datetie-format-converter 转换的时间是按照UTC-GMT时间来算的，所以对于中国来说，属于东八区，所以就写了一个php版本的自己使用。这里只是简单记录下自己开发的一个Unix时间戳转换的workflow的过程，详细教程请自行google或者参考 这篇教程. 一些基本概念workflow可以使用脚本语言来编写，包括但不限于bash、php、python、ruby等。workflow中的triggers、inputs、actions、ouputs等基本概念就不解释了，详细了解的可以自己一个个的试一试，反正总共加起来也不多。 Alfred XML格式数据Alfred中要求ouputs最后输出特定Schema的 XML内容。其实这一点我不太理解为什么，个人一直不喜欢XML格式的数据，重复臃肿、层级难于管理，就数据交换格式而言，个人比较倾向简单清晰易读的JSON，Alfred不支持返回JSON数据结果，不知道是不是由于MacOS的原因，没有深究。Alfred要求输出的内容以下：1234567&lt;items&gt; &lt;item autocomplete = \"autocompletex\" uid = \"123321\" arg = \"argsx\" &gt; &lt;title &gt;title&lt;/title&gt; &lt;subtitle &gt;subtitle&lt;/subtitle&gt; &lt;icon &gt;icon&lt;/icon&gt; &lt;/item&gt;&lt;/items&gt; 根节点为items 其中包括任意多个item节点，每一个item节点代表本次查询结果的一行。 每一个item节点包括若干parameter与childnode，其含义为： uid： 每一个item要有一个独立的uid，不可重复 valid：值为yes 或者 no, 若为no，该行结果不可被选择 autocomplete ： 自动补全的值， 使用tab可以令alfred自动补全为 autocompelete属性的值. arg：作为下一个模块的参数传递 该行item的标题，也是主要显示的位置。 该行字标题位置，会被显示为灰色小字 该行图标的文件名，其大小为64X64 pixels 接受参数Alfred可以通过query字段来获取数据的内容。 逻辑处理&amp;格式输出获取query的内容后，使用熟悉的脚本语言进行一些处理后组成转符合上面Schema的XML数据格式直接输出即可。 调试Alfred很人性化的为开发者提供了调试工具，在workflow开发界面的右上角Toggle debuggind mode即可在下方打开一个debug窗口输出一些调试信息，方便开发。 说明以下是开发的一个简单的时间戳转换workflow,代码没有做严格的输入检查，只是简单的将输入的内容通过php的date函数转换成人类可读的Y-m-d H:i:s格式.123456date_default_timezone_set('Asia/Shanghai');require_once ('workflows.php');$query = \"&#123;query&#125;\";$wf = new Workflows ();$wf-&gt;result ( time (), $query, date('Y-m-d H:i:s',$query), '', 'icon.png', 'yes' );echo $wf-&gt;toxml(); 其中worklows.php 中就只用到了 输出 XML 的方法，这个方法就是将resutl()中传递的参数组装成特定XML数据。 后续后来研究了下datetime-format-converter的源码，做了简单的修改，已经支持北京时间的转换，其实就是在作者的python代码中时间转换的时候加上了时区的设置，手动将时区设置为Asia/Shanghai即可。123456789101112131415def parse_query_value(query_str): \"\"\" Return value for the query string \"\"\" try: query_str = str(query_str).strip('\"\\' ') if query_str == 'now': d = utcnow().shift('Asia/Shanghai') else: # Parse datetime string or timestamp try: d = epoch(float(query_str)).shift(\"Asia/Shanghai\") except ValueError: d = parse(str(query_str)).shift('Asia/Shanghai') except (TypeError, ValueError): d = None return d 将第6、10、12行中时间转换加上了shift(&#39;Asia/Shanghai&#39;)1d = epoch(float(query_str)) 改为1d = epoch(float(query_str)).shift(\"Asia/Shanghai\") 即可。其实更好的做法是自动检测系统信息推断出用户所使用的时区并转换。 参考资料 http://myg0u.com/python/2015/05/23/tutorial-alfred-workflow.html http://www.deanishe.net/alfred-workflow/ http://www.deanishe.net/alfred-workflow/tutorial.html","categories":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"}],"tags":[{"name":"Alfred","slug":"Alfred","permalink":"http://yoursite.com/tags/Alfred/"},{"name":"workflow","slug":"workflow","permalink":"http://yoursite.com/tags/workflow/"}]},{"title":"解决MacOS Sierra 升级后原有的ssh private key无法通过验证","slug":"MacOS-Sierra-ssh-config","date":"2017-03-19T05:36:32.000Z","updated":"2017-03-19T06:14:42.000Z","comments":true,"path":"MacOS-Sierra-ssh-config/","link":"","permalink":"http://yoursite.com/MacOS-Sierra-ssh-config/","excerpt":"周末正好有空,就准备把mac pro 升级到最新的sierra版本，毕竟已经落后于apple官方两个比较大的版本了。 升级过程很简单，也很顺利。直接通过appstore上在线更新即可，下载完成之后安装向导步骤完成即可。 直到….我发现公司测试环境502之后，想要登陆到机器上去处理一下的时候，我的ssh key竟然毫无征兆的被deny了！升级之前能登陆服务器，升级之后无法登陆。","text":"周末正好有空,就准备把mac pro 升级到最新的sierra版本，毕竟已经落后于apple官方两个比较大的版本了。 升级过程很简单，也很顺利。直接通过appstore上在线更新即可，下载完成之后安装向导步骤完成即可。 直到….我发现公司测试环境502之后，想要登陆到机器上去处理一下的时候，我的ssh key竟然毫无征兆的被deny了！升级之前能登陆服务器，升级之后无法登陆。 问了其他同事，跳板机能正常登陆的，排除了机房出问题的可能性。那就说明这是本地的ssh agent升级后出问题了。 同时，我也试了下github的key是否也不能使用。结果正如我所料:123456ssh -v github.com..........debug1: Skipping ssh-dss key xxxx/xxxx/xxx/ - not in PubkeyAcceptedKeyTypes.....Permission denied (publickey). 更加证实了我的想法: 这是Mac升级后导致的后来 google 发现这个问题很正常，很多人都在升级后遇到了这个问题。同时也暂时采用了临时方案：1234Host \"github.com\" User \"git\" IdentityFile \"/xxx/xxxx/xxx\" PubkeyAcceptedKeyTypes=+ssh-dss 在.ssh/config 中添加了 PubkeyAcceptedKeyTypes=+ssh-dss 配置，让 ssh 接受 dsa 类型的key。 最终方案应该是采用更加安全的 RSA 算法来生成 key，长度为 2048的 RSA。1024长度的RSA已经有被暴力破解成功的记录了，所以建议采用 2048 长度1ssh-keygen -t rsa -b 2048 -C \"new key\" 当然，采用 ecdsa 更好，不过考虑到Openssl的兼容问题，在ecdsa未完全通用的情况下还是使用RSA比较好。","categories":[{"name":"os","slug":"os","permalink":"http://yoursite.com/categories/os/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://yoursite.com/tags/mac/"},{"name":"ssh","slug":"ssh","permalink":"http://yoursite.com/tags/ssh/"}]},{"title":"Linux zgrep使用笔记","slug":"Linux-zgrep","date":"2017-03-17T09:20:05.000Z","updated":"2017-03-18T15:01:02.000Z","comments":true,"path":"Linux-zgrep/","link":"","permalink":"http://yoursite.com/Linux-zgrep/","excerpt":"","text":"grep 可以用来搜索文件内容,而基于grep的 zgrep这可以用来在压缩包中搜索内容而不需要事先解压文件. 123456789101112131415161718192021222324252627282930313233343536[root@yourdream ~]# cat test.gopackage mainimport ( \"fmt\")func main()&#123; fmt.Println(\"Hello Golang!\");&#125;[root@yourdream ~]# tar zcf test.tar.gz test.go[root@yourdream ~]# file test.tar.gztest.tar.gz: gzip compressed data, from Unix, last modified: Fri Mar 17 17:23:09 2017[root@yourdream ~]# zgrep \"fmt\" test.tar.gzBinary file (standard input) matches[root@yourdream ~]# zgrep -a \"fmt\" test.tar.gz \"fmt\" fmt.Println(\"Hello Golang!\");[root@yourdream ~]# tar -tvf test.tar.gz-rw-r--r-- root/root 81 2017-03-17 17:18 test.go[root@yourdream ~]# tar -rvf test.tar.gz test/test/test/a.php[root@yourdream ~]# tar -tvf test.tar.gz-rw-r--r-- root/root 81 2017-03-17 17:18 test.godrwxr-xr-x root/root 0 2017-03-17 17:50 test/-rw-r--r-- root/root 1127 2017-03-17 17:50 test/a.php[root@yourdream ~]# zgrep -aHn \"Hello\" test.tar.gztest.tar.gz:6: fmt.Println(\"Hello Golang!\");test.tar.gz:16:echo 'Hello php'; 注意需要加上 -a 参数,让其二进制文件当做文本处理 tar -u -r 先压缩包中添加文件 tar -H 显示文件名 tar -n 显示行号","categories":[{"name":"notes","slug":"notes","permalink":"http://yoursite.com/categories/notes/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"zgrep","slug":"zgrep","permalink":"http://yoursite.com/tags/zgrep/"}]},{"title":"iptables使用笔记","slug":"Linux-iptables","date":"2017-03-17T07:07:10.000Z","updated":"2017-03-18T15:01:02.000Z","comments":true,"path":"Linux-iptables/","link":"","permalink":"http://yoursite.com/Linux-iptables/","excerpt":"Linux 下防火墙 iptables 命令使用笔记 查看目前iptables设置 iptables -vnL --line-numbers -v verbose 详细信息 -n 显示数字端口等 -L list ,默认会显示filter表的规则 --line-numbers 显示序号,删除、插入时有用 删除规则iptables -t table -D INPUT ruleNumber -t table name,默认filter表,filter|Nat|Mangle|Raw -D delete INPUT chain name,INPUT|OUTPUT|FORWARD|PREROUTING|POSTROUTING ruleNumber rule number,可以使用--line-numbers参数查看 查看状态/etc/init.d/iptables status 保存修改/etc/init.d/iptables save,规则保存在/etc/sysconfg/iptables文件中 开启|重启|关闭/etc/init.d/iptables start|restart|stop","text":"Linux 下防火墙 iptables 命令使用笔记 查看目前iptables设置 iptables -vnL --line-numbers -v verbose 详细信息 -n 显示数字端口等 -L list ,默认会显示filter表的规则 --line-numbers 显示序号,删除、插入时有用 删除规则iptables -t table -D INPUT ruleNumber -t table name,默认filter表,filter|Nat|Mangle|Raw -D delete INPUT chain name,INPUT|OUTPUT|FORWARD|PREROUTING|POSTROUTING ruleNumber rule number,可以使用--line-numbers参数查看 查看状态/etc/init.d/iptables status 保存修改/etc/init.d/iptables save,规则保存在/etc/sysconfg/iptables文件中 开启|重启|关闭/etc/init.d/iptables start|restart|stop examplesiptables -I INPUT -s 1.1.1.1 -p tcp -dport 6666 -m comment --comment &quot;some comment&quot; -j ACCEPT 向INPUT链中I(插入)一条规则,没有指定ruleNumber则插入到最前面 -s source,来源ip或者hostname -p protocol 协议 tcp,udp,icmp(ping包),all 等 /etc/protocols中protocol的均可以 -dport 目标端口 destination port,注意--dport和-dport -m match extension,启用扩展, comment是注释扩展 -j jump ACCEPT ACCEPT|DROP|REJECT|LOG 详细可参考 iptables详解,文章很详细!","categories":[{"name":"notes","slug":"notes","permalink":"http://yoursite.com/categories/notes/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"iptables","slug":"iptables","permalink":"http://yoursite.com/tags/iptables/"}]},{"title":"Go Get安装一些第三方库-网络问题","slug":"go-get-golang-x-packages","date":"2017-03-08T10:56:51.000Z","updated":"2017-03-18T15:01:02.000Z","comments":true,"path":"go-get-golang-x-packages/","link":"","permalink":"http://yoursite.com/go-get-golang-x-packages/","excerpt":"","text":"go在go get 一些 package时候的会由于众所周知的原因而无法下载。比如在安装 bee的时候有可能会遇到无法下载 golang.org/x/sys/unix 的问题。1unrecognized import path \"golang.org/x/sys/unix\" 解决方案：手动从github下载相应的package 12git clone --depth=1 https://github.com/golang/xxx.gitgit clone --depth=1 https://github.com/golang/xxx.git 注：xxx 为对应的需要的库 下载完成后，软链或者复制 到 $GOPATH/src/golang.org/x/ 下即可。1234567golang.org/└── x ├── net ├── sys └── tools4 directories 更为简便的方法：12345mkdir -p $GOPATH/src/golang.org/x/cd !$git clone https://github.com/golang/net.gitgit clone https://github.com/golang/sys.gitgit clone https://github.com/golang/tools.git","categories":[{"name":"go","slug":"go","permalink":"http://yoursite.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"http://yoursite.com/tags/go/"}]},{"title":"Atom 调整左侧目录字体大小","slug":"atom-set-font-size","date":"2017-03-07T14:39:49.000Z","updated":"2017-03-18T15:01:02.000Z","comments":true,"path":"atom-set-font-size/","link":"","permalink":"http://yoursite.com/atom-set-font-size/","excerpt":"","text":"刚刚安装好 atom的时候， 左侧的 tree 目录字体特别小，可以通过一下方式来设置 打开Atom-Stylesheet 找到 .tree-view 1234// style the background color of the tree view.tree-view &#123; // background-color: whitesmoke;&#125; 给 .tree-view 添加 font-size 即可： 123.tree-view &#123; font-size:16px;&#125; 当然，添加其他属性也是可以的，可以自己定制样式，颜色，字体，字号等，CSS语法","categories":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"}],"tags":[{"name":"atom","slug":"atom","permalink":"http://yoursite.com/tags/atom/"}]},{"title":"Atom设置代理","slug":"atom_set_proxy","date":"2017-03-07T14:10:01.000Z","updated":"2017-03-18T15:01:02.000Z","comments":true,"path":"atom_set_proxy/","link":"","permalink":"http://yoursite.com/atom_set_proxy/","excerpt":"由于众所周知的原因，Atom有时候安装插件的时候很慢甚至无法安装。可以通过设置代理来解决。前提是已经有一个可以使用的http代理。参考之前的文章：将socks5转为http代理 atom自带了一个工具 apm(atom package management) 这个工具可以用来设置一些系统配置 可以用apm config list 查看现有的系统配置信息 下面开始设置 http代理：","text":"由于众所周知的原因，Atom有时候安装插件的时候很慢甚至无法安装。可以通过设置代理来解决。前提是已经有一个可以使用的http代理。参考之前的文章：将socks5转为http代理 atom自带了一个工具 apm(atom package management) 这个工具可以用来设置一些系统配置 可以用apm config list 查看现有的系统配置信息 下面开始设置 http代理： 执行一下命令 123apm config set http-proxy http://host:portapm config set https-proxy http://host:portapm config set strict-ssl false 注意两点： https 配置的也是 http 而不是 https! set strict-ssl false 可以避免ssl 证书错误问题 其实直接修改 ~/.atom/.apmrc 文件也是可行的 具体说明可以查看 这里","categories":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"}],"tags":[{"name":"atom","slug":"atom","permalink":"http://yoursite.com/tags/atom/"},{"name":"proxy","slug":"proxy","permalink":"http://yoursite.com/tags/proxy/"}]},{"title":"Mac上使用Privoxy 将 socks5转换为 http 代理","slug":"transfer_socks5_to_http_proxy","date":"2017-03-06T15:07:20.000Z","updated":"2017-03-18T15:01:02.000Z","comments":true,"path":"transfer_socks5_to_http_proxy/","link":"","permalink":"http://yoursite.com/transfer_socks5_to_http_proxy/","excerpt":"shadowsocks 挺不错的，但是有些时候需要使用http代理来爬墙。这时候可以使用privoxy来将 socks5 代理转换为 http代理。 步骤如下： 首先，确保 shadowsocks 已经正常起来的，默认的本地socks5端口号为 1080,可以使用 netstat 和 lsof 命令查看端口情况。 安装privoxy, mac 使用 brew install privoxy 即可 安装完成后，修改privoxy配置文件","text":"shadowsocks 挺不错的，但是有些时候需要使用http代理来爬墙。这时候可以使用privoxy来将 socks5 代理转换为 http代理。 步骤如下： 首先，确保 shadowsocks 已经正常起来的，默认的本地socks5端口号为 1080,可以使用 netstat 和 lsof 命令查看端口情况。 安装privoxy, mac 使用 brew install privoxy 即可 安装完成后，修改privoxy配置文件 1vim /usr/local/etc/privoxy/config 修改内容如下： 12forward-socks5t / 127.0.0.1:1080 .listen-address 127.0.0.1:8118 listen-address 默认是监听本地8118端口，如果端口没有被占用，可以不用修改 启动privoxy1/usr/local/sbin/privoxy /usr/local/etc/privoxy/config 可以使用 ps aux|grep privoxy和 lsof -i:8118来检查是否成功启动 正常情况下,可以使用http代理了，代理地址http://127.0.0.1:8118","categories":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"}],"tags":[{"name":"proxy","slug":"proxy","permalink":"http://yoursite.com/tags/proxy/"},{"name":"socks5","slug":"socks5","permalink":"http://yoursite.com/tags/socks5/"},{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"},{"name":"privoxy","slug":"privoxy","permalink":"http://yoursite.com/tags/privoxy/"},{"name":"shadowsocks","slug":"shadowsocks","permalink":"http://yoursite.com/tags/shadowsocks/"}]}]}